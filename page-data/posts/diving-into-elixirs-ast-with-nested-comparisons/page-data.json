{"componentChunkName":"component---src-templates-post-js","path":"/posts/diving-into-elixirs-ast-with-nested-comparisons","result":{"data":{"markdownRemark":{"html":"<p>In this post, I'll explore something that happened me after trying to execute Python's nested comparisons (example: a > b > c) in Elixir.</p>\n<p>If you alredy tried it, you certainly got a message like this one:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8a2056ad7ed8a38c8cd97de1318f0914/fd28b/001.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.35135135135135%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABDElEQVQoz41SW3LCMAz0fZoWSPyO7SQEBu5/IVUrB4ZAoP3YkeSHdteyyvOZynyifjoKMuddiNS0eo3O0Dej1jXfggql0Hy90HS5UhhGwd56+tGWdsatgLX9Q73Z0CdNsXjyZSSbMtk+k2G4XCRizeVBaij3hfPEezEJwUtDqNGxZyRRhkUcBJoNBbD8zq407EJPPlfWgwv0degEuHjLV3h4161zCspgCVaM2E1iDaqRYx+kFZFaH9mJk9gxWhYhcYEqp7NMFxEYljodZ4rjJDkihgXSxHW9HITk3hiRCRWmhUTULQ99s/Jsp3myW6FXUYG5ZwVojKHsjP3z4T8OxfB3uE91Yf/PxXfnfgH/vEP4oRtFMwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Elixir Kernel Warning\"\n        title=\"Elixir Kernel Warning\"\n        src=\"/static/8a2056ad7ed8a38c8cd97de1318f0914/fcda8/001.png\"\n        srcset=\"/static/8a2056ad7ed8a38c8cd97de1318f0914/12f09/001.png 148w,\n/static/8a2056ad7ed8a38c8cd97de1318f0914/e4a3f/001.png 295w,\n/static/8a2056ad7ed8a38c8cd97de1318f0914/fcda8/001.png 590w,\n/static/8a2056ad7ed8a38c8cd97de1318f0914/fd28b/001.png 811w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>The most curious thing is that the <code class=\"language-text\">else</code> on this example was triggered, but <code class=\"language-text\">1 &lt; 2 &lt; 3</code> is <code class=\"language-text\">true</code>! This happened because Elixir actually processed something like the following way:</p>\n<div class=\"gatsby-highlight\" data-language=\"elixir\"><pre class=\"language-elixir\"><code class=\"language-elixir\">first_result <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span> <span class=\"token comment\"># returns true</span>\nfirst_result <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span> <span class=\"token comment\"># compares \"true &lt; 3\"</span>\n<span class=\"token boolean\">false</span> <span class=\"token comment\"># true is greater than 3 (?)</span></code></pre></div>\n<p>Before showing what I've developed to recreate this resource, first of all, it is interesting to see how a comparison looks like in the Elixir's <strong>A</strong>bstract <strong>S</strong>yntax <strong>T</strong>ree. Also, to simplify the example, I'll cover only nested comparisos for numbers (since the AST for variables is a little bit different).</p>\n<div class=\"gatsby-highlight\" data-language=\"elixir\"><pre class=\"language-elixir\"><code class=\"language-elixir\"><span class=\"token comment\"># if you type</span>\n\niex<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span> quote <span class=\"token keyword\">do</span>\n<span class=\"token operator\">...</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span>\n<span class=\"token operator\">...</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span> <span class=\"token keyword\">end</span>\n\n<span class=\"token comment\"># it will return</span>\n<span class=\"token punctuation\">{</span>\n  :<span class=\"token operator\">&lt;</span><span class=\"token punctuation\">,</span> <span class=\"token comment\"># operator</span>\n  <span class=\"token punctuation\">[</span><span class=\"token attr-name\">context:</span> Elixir<span class=\"token punctuation\">,</span> <span class=\"token attr-name\">import:</span> Kernel<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\"># context</span>\n  <span class=\"token punctuation\">[</span> <span class=\"token comment\"># two items list (a value or another tuple)</span>\n    <span class=\"token punctuation\">{</span>\n      :<span class=\"token operator\">&lt;</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">[</span><span class=\"token attr-name\">context:</span> Elixir<span class=\"token punctuation\">,</span> <span class=\"token attr-name\">import:</span> Kernel<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token number\">3</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>By knowing what is the format for this kind of operation (a tuple with: an operator atom, a context list, a list of args - that can be another tuple like this one described), now we can define what is needed to do:</p>\n<ul>\n<li>Do not import the <code class=\"language-text\">Kernel.if/2</code></li>\n<li>Rewrite the <code class=\"language-text\">if</code> macro;</li>\n<li>Recursively look into the tuple shown above;</li>\n<li>Rewrite the ast into something Elixir knows:</li>\n<li>I decided to create a list of tuples like this: <code class=\"language-text\">{:operator, left_arg, right_arg}</code>;</li>\n<li>By the example above, when you have one item as a number (3) and another on a sub tuple, it is needed to combine the \"real\" args (1, 2, 3) in a way to have a pair for (1, 2) and another for (2, 3) - this way, the code could be rewritten to <code class=\"language-text\">1 &lt; 2 and 2 &lt; 3</code>;</li>\n</ul>\n<p>The code is:</p>\n<div class=\"gatsby-highlight\" data-language=\"elixir\"><pre class=\"language-elixir\"><code class=\"language-elixir\"><span class=\"token keyword\">defmodule</span> Nested<span class=\"token punctuation\">.</span>Definition <span class=\"token keyword\">do</span>\n  <span class=\"token attribute variable\">@signals</span> <span class=\"token string\">~w/> &lt; == != &lt;= >=/a</span>\n\n  <span class=\"token keyword\">def</span> decode_ast<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>signal<span class=\"token punctuation\">,</span> _context<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>left_arg<span class=\"token punctuation\">,</span> right_arg<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">when</span> is_tuple<span class=\"token punctuation\">(</span>left_arg<span class=\"token punctuation\">)</span> <span class=\"token keyword\">and</span> signal <span class=\"token operator\">in</span> <span class=\"token attribute variable\">@signals</span> <span class=\"token keyword\">do</span>\n    <span class=\"token punctuation\">{</span>_signal<span class=\"token punctuation\">,</span> _context<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>_left_arg<span class=\"token punctuation\">,</span> real_left_arg<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> left_arg\n    decode_ast<span class=\"token punctuation\">(</span>left_arg<span class=\"token punctuation\">)</span> <span class=\"token operator\">++</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>signal<span class=\"token punctuation\">,</span> real_left_arg<span class=\"token punctuation\">,</span> right_arg<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">def</span> decode_ast<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>signal<span class=\"token punctuation\">,</span> _context<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>left_arg<span class=\"token punctuation\">,</span> right_arg<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">when</span> is_tuple<span class=\"token punctuation\">(</span>right_arg<span class=\"token punctuation\">)</span> <span class=\"token keyword\">and</span> signal <span class=\"token operator\">in</span> <span class=\"token attribute variable\">@signals</span> <span class=\"token keyword\">do</span>\n    <span class=\"token punctuation\">{</span>_signal<span class=\"token punctuation\">,</span> _context<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>real_right_arg<span class=\"token punctuation\">,</span> _left_arg<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> right_arg\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>signal<span class=\"token punctuation\">,</span> left_arg<span class=\"token punctuation\">,</span> real_right_arg<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">++</span> decode_ast<span class=\"token punctuation\">(</span>right_arg<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">def</span> decode_ast<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>signal<span class=\"token punctuation\">,</span> _context<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>left_arg<span class=\"token punctuation\">,</span> right_arg<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">when</span> signal <span class=\"token operator\">in</span> <span class=\"token attribute variable\">@signals</span> <span class=\"token keyword\">do</span>\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>signal<span class=\"token punctuation\">,</span> left_arg<span class=\"token punctuation\">,</span> right_arg<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n\n<span class=\"token comment\"># And an example here:</span>\nNested<span class=\"token punctuation\">.</span>Definition<span class=\"token punctuation\">.</span>decode_ast<span class=\"token punctuation\">(</span>quote <span class=\"token attr-name\">do:</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span> <span class=\"token operator\">&lt;=</span> <span class=\"token number\">3</span> <span class=\"token operator\">&lt;=</span> <span class=\"token number\">3</span> <span class=\"token operator\">></span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># it will return the combination of each operation</span>\n<span class=\"token comment\"># [{:&lt;, 1, 2}, {:&lt;=, 2, 3}, {:&lt;=, 3, 3}, {:>, 3, 1}, {:&lt;, 1, 5}]</span></code></pre></div>\n<p>The last thing now is to loop over the generated list and apply each operation to the pair of values, and also make it available inside <code class=\"language-text\">if</code> by redefining this macro. Include the following code on the module you already have:</p>\n<div class=\"gatsby-highlight\" data-language=\"elixir\"><pre class=\"language-elixir\"><code class=\"language-elixir\"><span class=\"token keyword\">defmodule</span> Nested<span class=\"token punctuation\">.</span>Definition <span class=\"token keyword\">do</span>\n  defmacro __using__<span class=\"token punctuation\">(</span>_args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>\n    quote <span class=\"token keyword\">do</span>\n      <span class=\"token keyword\">import</span> Kernel<span class=\"token punctuation\">,</span> <span class=\"token attr-name\">except:</span> <span class=\"token punctuation\">[</span><span class=\"token attr-name\">if:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n      <span class=\"token keyword\">import</span> Nested<span class=\"token punctuation\">.</span>Definition<span class=\"token punctuation\">,</span> <span class=\"token attr-name\">only:</span> <span class=\"token punctuation\">[</span><span class=\"token attr-name\">if:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n\n  defmacro <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>condition<span class=\"token punctuation\">,</span> clauses<span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>\n    build_if<span class=\"token punctuation\">(</span>condition<span class=\"token punctuation\">,</span> clauses<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">defp</span> build_if<span class=\"token punctuation\">(</span>condition<span class=\"token punctuation\">,</span> <span class=\"token attr-name\">do:</span> do_clause<span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>\n    build_if<span class=\"token punctuation\">(</span>condition<span class=\"token punctuation\">,</span> <span class=\"token attr-name\">do:</span> do_clause<span class=\"token punctuation\">,</span> <span class=\"token attr-name\">else:</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">defp</span> build_if<span class=\"token punctuation\">(</span>condition<span class=\"token punctuation\">,</span> <span class=\"token attr-name\">do:</span> do_clause<span class=\"token punctuation\">,</span> <span class=\"token attr-name\">else:</span> else_clause<span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>\n    final_result <span class=\"token operator\">=</span>\n      condition\n      <span class=\"token operator\">|></span> decode_ast<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token operator\">|></span> Enum<span class=\"token punctuation\">.</span>reduce_while<span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">fn</span> <span class=\"token punctuation\">{</span>signal<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> _acc <span class=\"token operator\">-></span>\n        <span class=\"token comment\"># I used the reduce_while to avoid doing all comparisons</span>\n        <span class=\"token comment\"># if some of them return false (so will stop by returning :halt)</span>\n\n        <span class=\"token comment\"># to execute each operation, will apply it to erlang core module</span>\n        <span class=\"token comment\"># like running :erlang.>=(3, 1)</span>\n        result <span class=\"token operator\">=</span> apply<span class=\"token punctuation\">(</span><span class=\"token atom symbol\">:erlang</span><span class=\"token punctuation\">,</span> rewrite_operator<span class=\"token punctuation\">(</span>signal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n        Kernel<span class=\"token punctuation\">.</span><span class=\"token keyword\">if</span> result <span class=\"token keyword\">do</span>\n          <span class=\"token punctuation\">{</span><span class=\"token atom symbol\">:cont</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n          <span class=\"token punctuation\">{</span><span class=\"token atom symbol\">:halt</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">end</span>\n      <span class=\"token keyword\">end</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\"># lastely, unquote the code given in `do:` and `else:` keywords</span>\n    <span class=\"token comment\"># on the main function</span>\n    quote <span class=\"token keyword\">do</span>\n      <span class=\"token keyword\">if</span> unquote<span class=\"token punctuation\">(</span>final_result<span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>\n        unquote<span class=\"token punctuation\">(</span>do_clause<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">else</span>\n        unquote<span class=\"token punctuation\">(</span>else_clause<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">end</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token comment\"># this is used because erlang doesn't have</span>\n  <span class=\"token comment\"># the \"!=\" operator, and uses \"/=\"</span>\n  <span class=\"token keyword\">defp</span> rewrite_operator<span class=\"token punctuation\">(</span>:<span class=\"token operator\">!=</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">do:</span> :<span class=\"token string\">\"/=\"</span>\n  <span class=\"token keyword\">defp</span> rewrite_operator<span class=\"token punctuation\">(</span>op<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">do:</span> op\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>Now, it is possible to <code class=\"language-text\">use</code> this code on any module by typing:</p>\n<div class=\"gatsby-highlight\" data-language=\"elixir\"><pre class=\"language-elixir\"><code class=\"language-elixir\"><span class=\"token keyword\">defmodule</span> Nested <span class=\"token keyword\">do</span>\n  <span class=\"token keyword\">use</span> Nested<span class=\"token punctuation\">.</span>Definition\n\n  <span class=\"token keyword\">def</span> test <span class=\"token keyword\">do</span>\n    <span class=\"token keyword\">if</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span> <span class=\"token operator\">>=</span> <span class=\"token number\">2</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span> <span class=\"token keyword\">do</span>\n      IO<span class=\"token punctuation\">.</span>puts<span class=\"token punctuation\">(</span><span class=\"token string\">\"IT REALLY WORKS!\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>Finished! Just made a Python operator \"works\" in Elixir. But there are some problems that I avoided on this post, since I didn't want it to be a real/useful implementation because it is nicier to write the Elixir way (1 &#x3C; 2 and 2 &#x3C; 3), so:</p>\n<ul>\n<li>it doesn't work with variables (see the quoted expression using variables and will notice that the AST is different);</li>\n<li>by removing the Kernel implementation, some options like <code class=\"language-text\">if(true, do: IO.puts(&quot;true&quot;))</code> just stopped working, since they don't match the <code class=\"language-text\">decode_ast</code> clauses.</li>\n</ul>\n<p>If you want to check the full source, just visit my github <a href=\"https://github.com/duzzifelipe/ex_nested_operators\" target=\"_blank\" rel=\"nofollow\">https://github.com/duzzifelipe/ex_nested_operators</a>.</p>","frontmatter":{"date":"08/08/2020","slug":"diving-into-elixirs-ast-with-nested-comparisons","title":"Diving into Elixir's AST with nested comparisons"}}},"pageContext":{"slug":"diving-into-elixirs-ast-with-nested-comparisons"}}}